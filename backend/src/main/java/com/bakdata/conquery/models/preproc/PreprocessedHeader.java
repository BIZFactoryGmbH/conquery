package com.bakdata.conquery.models.preproc;

import java.util.Map;
import java.util.StringJoiner;

import com.bakdata.conquery.models.datasets.Column;
import com.bakdata.conquery.models.datasets.Table;
import com.bakdata.conquery.models.events.parser.MajorTypeId;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Header containing data about a Preprocessed Csv file. Generated by running {@link com.bakdata.conquery.commands.PreprocessorCommand}.
 *
 * @implSpec The Columns and their order must directly match the layout in the data.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Slf4j
public class PreprocessedHeader {
	/**
	 * The name/tag of an import.
	 */
	private String name;

	/**
	 * The specific table id to be loaded into.
	 */
	private String table;

	/**
	 * Number of rows in the Preprocessed file.
	 */
	private long rows;

	/**
	 * The specific columns and their associated MajorType for validation.
	 */
	private Map<String, MajorTypeId> columns;

	/**
	 * A hash to check if any of the underlying files for generating this CQPP has changed.
	 */
	private int validityHash;


	/**
	 * Verify that the supplied table matches the preprocessed' data in shape.
	 */
	public void assertMatch(Table table) {
		StringJoiner errors = new StringJoiner("\n");

		if (table.getColumns().length != getColumns().size()) {
			errors.add(String.format("Length=`%d` does not match table Length=`%d`", getColumns().size(), table.getColumns().length));
		}

		for (int i = 0; i < Math.min(table.getColumns().length, getColumns().size()); i++) {
			final Column column = table.getColumns()[i];

			if(!getColumns().containsKey(column.getName())){
				errors.add(String.format("Column[%s] is missing in Import.", column.getName()));
			}

			if (!getColumns().get(column.getName()).equals(column.getType())) {
				errors.add(String.format("ImportColumn[%s]#%s does not match Column[%s]#%s", getColumns().get(column.getName()), table.getColumns()[i]));
			}
		}

		if (errors.length() != 0) {
			log.error(errors.toString());
			throw new IllegalArgumentException(String.format("Headers[%s.%s] do not match Table[%s]", getTable(), getName(), table.getId()));
		}
	}
}
